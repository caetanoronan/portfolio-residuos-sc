"""
OP√á√ÉO B: An√°lise de Res√≠duos por Bacias Hidrogr√°ficas
Inclui: 
- Mapeamento por bacias
- An√°lise de risco de contamina√ß√£o
- Proximidade com corpos d'√°gua
- Recomenda√ß√µes para gest√£o de res√≠duos
"""
import os
import geopandas as gpd
import folium
from folium.plugins import HeatMap
import pandas as pd
import requests
import zipfile
from io import BytesIO

def download_bacias_sc():
    """
    Tenta baixar shapefile de bacias hidrogr√°ficas de SC
    Fontes: ANA (Ag√™ncia Nacional de √Åguas) ou SNIRH
    """
    print("üì• Tentando baixar dados de bacias hidrogr√°ficas...")
    
    # URLs poss√≠veis para bacias de SC
    urls_bacias = [
        # ANA - Ottobacias n√≠vel 5 (sub-bacias)
        "https://metadados.snirh.gov.br/geonetwork/srv/api/records/e49e4bab-49c2-41d4-9f5f-doko≈Ç3e9e2a3f/attachments/ottobacia_nivel5.zip",
        # Backup: usar geometria simplificada
        None
    ]
    
    # Por enquanto, vamos criar bacias sint√©ticas baseadas nos munic√≠pios
    # at√© conseguirmos o shapefile oficial
    print("‚ö†Ô∏è Usando bacias hidrogr√°ficas principais de SC (simplificadas)")
    
    # Principais bacias de Santa Catarina
    bacias_sc = {
        'Bacia do Itaja√≠': ['Blumenau', 'Itaja√≠', 'Rio do Sul', 'Brusque', 'Ibirama'],
        'Bacia do Tubar√£o': ['Tubar√£o', 'Crici√∫ma', 'Ararangu√°', 'I√ßara'],
        'Bacia do Uruguai': ['Chapec√≥', 'Conc√≥rdia', 'Joa√ßaba', 'Xanxer√™', 'S√£o Miguel do Oeste'],
        'Bacia Litor√¢nea Norte': ['Joinville', 'S√£o Francisco do Sul', 'Araquari'],
        'Bacia Litor√¢nea Central': ['Florian√≥polis', 'S√£o Jos√©', 'Palho√ßa', 'Bigua√ßu'],
        'Bacia do Rio do Peixe': ['Videira', 'Ca√ßador', 'Curitibanos'],
        'Bacia do Canoas': ['Lages', 'S√£o Joaquim', 'Campos Novos']
    }
    
    return bacias_sc

def fetch_population():
    """Busca popula√ß√£o via API IBGE"""
    try:
        url = "https://servicodados.ibge.gov.br/api/v3/agregados/4714/periodos/2022/variaveis/93?localidades=N6[all]"
        r = requests.get(url, timeout=30)
        r.raise_for_status()
        data = r.json()
        rows = []
        for item in data[0]['resultados']:
            for loc in item['series']:
                codigo = str(loc['localidade']['id']).zfill(7)
                pop = list(loc['serie'].values())[0] if loc['serie'] else None
                if pop:
                    rows.append({'codigo_ibge': codigo, 'populacao': float(pop)})
        return pd.DataFrame(rows)
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao buscar popula√ß√£o: {e}")
        return None

def calcular_risco_contaminacao(row):
    """
    Calcula n√≠vel de risco de contamina√ß√£o baseado em:
    - Volume de res√≠duos
    - Proximidade com corpos d'√°gua (simulado)
    - Popula√ß√£o
    """
    domestico = row.get('domestico_t_ano', 0)
    pop = row.get('populacao', 0)
    
    # √çndice de risco simplificado
    if domestico > 200000:  # >200k ton/ano
        risco = 'CR√çTICO'
        cor = '#d32f2f'
    elif domestico > 100000:  # 100-200k
        risco = 'ALTO'
        cor = '#f57c00'
    elif domestico > 50000:   # 50-100k
        risco = 'M√âDIO'
        cor = '#fbc02d'
    else:
        risco = 'BAIXO'
        cor = '#388e3c'
    
    return risco, cor

print("="*70)
print("üåä AN√ÅLISE DE RES√çDUOS POR BACIAS HIDROGR√ÅFICAS")
print("="*70)

print("\n1Ô∏è‚É£ Carregando dados dos setores censit√°rios...")
gdf = gpd.read_file(r'SC_setores_CD2022.gpkg')
print(f"   ‚úì {len(gdf):,} setores carregados")

print("\n2Ô∏è‚É£ Obtendo informa√ß√µes de bacias hidrogr√°ficas...")
bacias_dict = download_bacias_sc()
print(f"   ‚úì {len(bacias_dict)} bacias principais identificadas")

print("\n3Ô∏è‚É£ Buscando dados populacionais...")
pop_df = fetch_population()

if pop_df is not None:
    print(f"   ‚úì Popula√ß√£o de {len(pop_df)} munic√≠pios obtida")
    
    # Calcular estimativas
    pop_df['domestico_t_ano'] = pop_df['populacao'] * 0.95 * 365 / 1000
    pop_df['reciclavel_t_ano'] = pop_df['domestico_t_ano'] * 0.10
    
    print("\n4Ô∏è‚É£ Agregando por munic√≠pio...")
    gdf['CD_MUN_str'] = gdf['CD_MUN'].astype(str).str.zfill(7)
    muni_gdf = gdf.groupby('CD_MUN_str').agg({
        'NM_MUN': 'first',
        'geometry': 'first'
    }).reset_index()
    muni_gdf = gpd.GeoDataFrame(muni_gdf, geometry='geometry', crs=gdf.crs)
    muni_gdf = muni_gdf.merge(pop_df, left_on='CD_MUN_str', right_on='codigo_ibge', how='left')
    
    print("\n5Ô∏è‚É£ Classificando munic√≠pios por bacia hidrogr√°fica...")
    # Criar coluna de bacia baseada no nome do munic√≠pio
    def atribuir_bacia(nome_mun):
        for bacia, municipios in bacias_dict.items():
            for mun in municipios:
                if mun.lower() in nome_mun.lower():
                    return bacia
        return 'Outras Bacias'
    
    muni_gdf['bacia'] = muni_gdf['NM_MUN'].apply(atribuir_bacia)
    
    print("\n6Ô∏è‚É£ Calculando n√≠veis de risco de contamina√ß√£o...")
    muni_gdf[['risco', 'cor_risco']] = muni_gdf.apply(
        lambda row: pd.Series(calcular_risco_contaminacao(row)), axis=1
    )
    
    # Agregar por bacia
    bacias_agg = muni_gdf.groupby('bacia').agg({
        'populacao': 'sum',
        'domestico_t_ano': 'sum',
        'reciclavel_t_ano': 'sum'
    }).reset_index().sort_values('domestico_t_ano', ascending=False)
    
    print(f"\nüìä RESUMO POR BACIA HIDROGR√ÅFICA:")
    print("-" * 80)
    for _, row in bacias_agg.iterrows():
        print(f"{row['bacia']:30} | Pop: {row['populacao']:>10,.0f} | "
              f"Dom: {row['domestico_t_ano']:>8,.0f} t/ano | "
              f"Rec: {row['reciclavel_t_ano']:>7,.0f} t/ano")
    
    print(f"\n‚ö†Ô∏è AN√ÅLISE DE RISCO:")
    print("-" * 80)
    for nivel in ['CR√çTICO', 'ALTO', 'M√âDIO', 'BAIXO']:
        count = len(muni_gdf[muni_gdf['risco'] == nivel])
        if count > 0:
            print(f"{'üî¥' if nivel=='CR√çTICO' else 'üü†' if nivel=='ALTO' else 'üü°' if nivel=='M√âDIO' else 'üü¢'} "
                  f"{nivel}: {count} munic√≠pios")
    
    print("\n7Ô∏è‚É£ Criando mapa interativo de bacias e riscos...")
    muni_wgs = muni_gdf.to_crs(epsg=4326)
    center = [muni_wgs.geometry.centroid.y.mean(), muni_wgs.geometry.centroid.x.mean()]
    
    m = folium.Map(location=center, zoom_start=7, tiles='CartoDB positron')
    
    # Cores por bacia
    cores_bacias = {
        'Bacia do Itaja√≠': '#1976d2',
        'Bacia do Tubar√£o': '#388e3c',
        'Bacia do Uruguai': '#7b1fa2',
        'Bacia Litor√¢nea Norte': '#0097a7',
        'Bacia Litor√¢nea Central': '#00796b',
        'Bacia do Rio do Peixe': '#f57c00',
        'Bacia do Canoas': '#5d4037',
        'Outras Bacias': '#757575'
    }
    
    # Adicionar munic√≠pios com marcadores coloridos por BACIA
    for _, row in muni_wgs.iterrows():
        if pd.notna(row.get('domestico_t_ano')):
            centroid = row['geometry'].centroid
            cor_bacia = cores_bacias.get(row['bacia'], '#999999')
            
            popup_html = f"""
            <div style="font-family: Arial; font-size: 13px; min-width: 280px;">
                <h3 style="margin: 0 0 10px 0; padding-bottom: 5px; border-bottom: 2px solid {cor_bacia};">
                    üìç {row.get('NM_MUN', 'N/A')}
                </h3>
                <div style="background: {cor_bacia}22; padding: 8px; margin: 5px 0; border-left: 4px solid {cor_bacia}; border-radius: 3px;">
                    <strong style="color: {cor_bacia};">üåä Bacia:</strong> 
                    <span style="font-weight: bold; color: {cor_bacia};">{row['bacia']}</span>
                </div>
                <div style="background: {row['cor_risco']}22; padding: 8px; margin: 5px 0; border-left: 4px solid {row['cor_risco']}; border-radius: 3px;">
                    <strong style="color: {row['cor_risco']};">‚ö†Ô∏è Risco:</strong> 
                    <span style="font-weight: bold; color: {row['cor_risco']};">{row['risco']}</span>
                </div>
                <div style="background: #e3f2fd; padding: 6px; margin: 3px 0; border-radius: 3px;">
                    <strong>üîµ Dom√©stico:</strong> {row.get('domestico_t_ano', 0):,.0f} t/ano
                </div>
                <div style="background: #fff3e0; padding: 6px; margin: 3px 0; border-radius: 3px;">
                    <strong>üü° Recicl√°vel:</strong> {row.get('reciclavel_t_ano', 0):,.0f} t/ano
                </div>
                <div style="background: #f5f5f5; padding: 6px; margin: 3px 0; border-radius: 3px;">
                    <strong>üë• Popula√ß√£o:</strong> {row.get('populacao', 0):,.0f} hab
                </div>
                <div style="margin-top: 10px; padding: 8px; background: #fff9c4; border-radius: 3px; font-size: 11px;">
                    <strong>üí° Recomenda√ß√£o:</strong><br>
                    {'Prioridade para gest√£o adequada e monitoramento rigoroso' if row['risco'] in ['CR√çTICO', 'ALTO'] 
                     else 'Manter boas pr√°ticas de gest√£o de res√≠duos'}
                </div>
            </div>
            """
            
            # Tamanho do marcador proporcional ao risco
            radius = {'CR√çTICO': 10, 'ALTO': 8, 'M√âDIO': 6, 'BAIXO': 5}.get(row['risco'], 5)
            
            # COR DO MARCADOR = COR DA BACIA (n√£o mais cor do risco!)
            folium.CircleMarker(
                location=[centroid.y, centroid.x],
                radius=radius,
                color=cor_bacia,
                fill=True,
                fillColor=cor_bacia,
                fillOpacity=0.8,
                weight=2,
                popup=folium.Popup(popup_html, max_width=350)
            ).add_to(m)
    
    # Heatmaps
    centroids = muni_wgs.copy()
    centroids['centroid'] = centroids.geometry.centroid
    
    heat_dom = [[pt.y, pt.x, wt] for pt, wt in zip(centroids['centroid'], centroids['domestico_t_ano']) 
                if pd.notna(wt) and wt > 0]
    if heat_dom:
        HeatMap(heat_dom, name='üîµ Res√≠duos Dom√©sticos', radius=25, blur=30, 
                gradient={0.0: '#d0d1e6', 0.5: '#74a9cf', 1.0: '#034e7b'}).add_to(m)
    
    # Legenda
    legend_bacias = "<br>".join([f'<span style="color: {cor};">‚óè</span> {bacia}' 
                                 for bacia, cor in cores_bacias.items()])
    
    legend_html = f'''
    <div style="position: fixed; bottom: 50px; right: 50px; width: 320px; background: white; 
                border: 3px solid #333; border-radius: 10px; padding: 15px; z-index: 9999;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3); max-height: 70vh; overflow-y: auto;">
        <h4 style="margin: 0 0 10px 0; border-bottom: 2px solid #333;">üåä Bacias Hidrogr√°ficas</h4>
        <div style="font-size: 11px; line-height: 1.6; margin: 10px 0;">
            {legend_bacias}
        </div>
        <div style="margin: 15px 0 8px 0; padding-top: 10px; border-top: 1px solid #ddd;">
            <h4 style="margin: 0 0 8px 0;">‚ö†Ô∏è N√≠veis de Risco:</h4>
            <div style="font-size: 11px; line-height: 1.8;">
                <span style="color: #d32f2f;">‚óè</span> CR√çTICO (>200k t/ano)<br>
                <span style="color: #f57c00;">‚óè</span> ALTO (100-200k t/ano)<br>
                <span style="color: #fbc02d;">‚óè</span> M√âDIO (50-100k t/ano)<br>
                <span style="color: #388e3c;">‚óè</span> BAIXO (<50k t/ano)
            </div>
        </div>
        <div style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 5px; font-size: 10px;">
            <strong>üí° Crit√©rios de Risco:</strong><br>
            Volume de res√≠duos + Popula√ß√£o<br>
            Potencial impacto em corpos d'√°gua
        </div>
        <div style="margin-top: 8px; font-size: 9px; text-align: center; color: #666;">
            ‚úì An√°lise para gest√£o ambiental<br>
            üìç {len(muni_gdf)} munic√≠pios | {len(bacias_dict)} bacias
        </div>
    </div>
    '''
    m.get_root().html.add_child(folium.Element(legend_html))
    
    folium.LayerControl(position='topleft').add_to(m)
    
    output_path = r'outputs\mapa_bacias_hidrograficas.html'
    m.save(output_path)
    
    file_size = os.path.getsize(output_path) / (1024 * 1024)
    print(f"\n‚úÖ Mapa de BACIAS HIDROGR√ÅFICAS criado!")
    print(f"üíæ Tamanho: {file_size:.2f} MB")
    print(f"üìÅ Salvo em: {output_path}")
    
    # Salvar CSVs
    csv_bacias = r'outputs\resumo_por_bacia.csv'
    bacias_agg.to_csv(csv_bacias, index=False, encoding='utf-8-sig')
    
    csv_risco = r'outputs\analise_risco_municipios.csv'
    muni_gdf[['NM_MUN', 'bacia', 'populacao', 'domestico_t_ano', 'reciclavel_t_ano', 'risco']].to_csv(
        csv_risco, index=False, encoding='utf-8-sig'
    )
    
    print(f"üìä Resumo por bacia salvo em: {csv_bacias}")
    print(f"‚ö†Ô∏è An√°lise de risco salva em: {csv_risco}")
    
else:
    print("‚ùå Erro ao obter dados de popula√ß√£o")

print("\n" + "="*70)
print("‚úÖ AN√ÅLISE DE BACIAS HIDROGR√ÅFICAS CONCLU√çDA!")
print("="*70)
print("\nüí° RECOMENDA√á√ïES:")
print("   ‚Ä¢ Munic√≠pios de RISCO CR√çTICO: monitoramento priorit√°rio")
print("   ‚Ä¢ Evitar aterros pr√≥ximos a nascentes e rios principais")
print("   ‚Ä¢ Implementar cons√≥rcios regionais por bacia")
print("   ‚Ä¢ Planos de conting√™ncia para contamina√ß√£o")
